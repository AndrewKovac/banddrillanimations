<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Quarter-Wheel — Embed (fixed cam, metronome, RIGHT wheel)</title>
<style>
  :root{ --ink:#1f3161; --accent:#2948a8; --grid:#8ea0bf; --bg:#ffffff; }
  html,body{margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1200px;margin:12px auto;padding:0 10px}
  canvas{width:100%;height:auto;background:#fff;border-radius:12px;border:1px solid #e1e7f5}
  .panel{background:#f7faff;border:1px solid #e1e7f5;border-radius:12px;padding:10px;margin-top:8px}
  .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .grow{flex:1}
  .big{font-weight:700;color:var(--accent);font-variant-numeric:tabular-nums}
  input[type=range]{width:100%}
  button{background:var(--ink);color:#fff;border:none;border-radius:8px;padding:8px 12px;cursor:pointer}
  button.secondary{background:#e7ecf6;color:#1f3161}
  .timeline{position:relative;height:52px;margin:6px 0}
  .timeline>canvas{width:100%;height:100%;display:block}
  .labels{display:flex;justify-content:space-between;font-size:12px;color:#556;margin-top:2px}
  .sp{display:inline-flex;align-items:center;gap:6px}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="stage" width="1200" height="900" aria-label="wheel canvas"></canvas>
  <div class="panel">
    <div class="row">
      <span class="big">Pace:</span><span id="paceOut" class="big">0</span>
      <input id="pace" type="range" min="0" max="36" step="1" value="0" class="grow">
      <div class="sp"><button id="play">▶ Play</button><button id="pause" class="secondary">Pause</button></div>
      <div class="sp">Speed (×): <input id="speed" type="range" min="0.25" max="2.5" step="0.25" value="1" style="width:160px"></div>
      <div class="sp">Files: <input id="files" type="number" min="3" max="12" value="6" style="width:60px"></div>
      <div class="sp">Ranks: <input id="ranks" type="number" min="3" max="12" value="6" style="width:60px"></div>
      <div class="sp">Pace px: <input id="pacePx" type="number" min="20" max="80" value="36" style="width:70px"></div>
      <label class="sp"><input type="checkbox" id="clicks" checked> Metronome</label>
    </div>
    <div class="timeline"><canvas id="ticks" width="1000" height="52"></canvas></div>
    <div class="labels" id="tickLabels"></div>
  </div>
</div>

<script>
(function(){
  const stage = document.getElementById('stage');
  const ctx = stage.getContext('2d');
  const paceSlider = document.getElementById('pace');
  const paceOut = document.getElementById('paceOut');
  const ticks = document.getElementById('ticks');
  const tctx = ticks.getContext('2d');
  const labels = document.getElementById('tickLabels');
  const playBtn = document.getElementById('play');
  const pauseBtn = document.getElementById('pause');
  const speed = document.getElementById('speed');
  const filesInp = document.getElementById('files');
  const ranksInp = document.getElementById('ranks');
  const pacePxInp = document.getElementById('pacePx');
  const clicks = document.getElementById('clicks');

  let F = parseInt(filesInp.value,10);
  let R = parseInt(ranksInp.value,10);
  let px = parseFloat(pacePxInp.value);

  let t = 0;
  let playing=false, lastTs=0, acc=0;
  function pps(){ return 2*parseFloat(speed.value); }

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  filesInp.addEventListener('input', ()=>{ F = clamp(parseInt(filesInp.value,10)||6,3,12); recalcCamera(); draw(); });
  ranksInp.addEventListener('input', ()=>{ R = clamp(parseInt(ranksInp.value,10)||6,3,12); recalcCamera(); draw(); });
  pacePxInp.addEventListener('input', ()=>{ px = clamp(parseFloat(pacePxInp.value)||36,20,80); recalcCamera(); draw(); });

  function drawTicks(){
    const w=ticks.width, L=10, Rg=10, usable=w-L-Rg;
    tctx.clearRect(0,0,w,ticks.height);
    tctx.beginPath(); tctx.moveTo(L,1); tctx.lineTo(w-Rg,1);
    tctx.strokeStyle='#c1cbe0'; tctx.stroke();
    for(let p=0;p<=36;p++){
      const x=L + (p/36)*usable;
      const major=(p%4===0);
      tctx.beginPath(); tctx.moveTo(x,1); tctx.lineTo(x, major?20:12);
      tctx.strokeStyle=major?'#1f3161':'#8ea0bf'; tctx.stroke();
    }
    labels.innerHTML='';
    for(let p=0;p<=36;p+=4){ const s=document.createElement('span'); s.textContent=p; labels.appendChild(s); }
  }
  drawTicks();

  function setT(v, doClick=true){ 
    t=Math.max(0,Math.min(36, Math.round(v))); 
    paceSlider.value=t; paceOut.textContent=t.toString(); 
    draw(); 
    if(doClick) metronome(t);
  }
  paceSlider.addEventListener('input', e=>{ playing=false; setT(parseInt(e.target.value,10)); });
  playBtn.addEventListener('click', ()=>{ if(playing) return; playing=true; lastTs=performance.now(); requestAnimationFrame(step); });
  pauseBtn.addEventListener('click', ()=> playing=false);
  function step(ts){
    const dt=(ts-lastTs)/1000; lastTs=ts; acc += dt;
    const per = 1/pps();
    while(acc >= per){ acc -= per; setT(t+1); }
    if(t>36) t=0;
    if(playing) requestAnimationFrame(step);
  }

  // Metronome
  let ac = null;
  function metronome(p){
    if(!clicks.checked) return;
    if(!ac){ try{ ac = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){ return; } }
    const now = ac.currentTime;
    const osc = ac.createOscillator();
    const gain = ac.createGain();
    const major = (p%4===0);
    osc.type = 'square';
    osc.frequency.value = major ? 1100 : 800;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(major?0.6:0.4, now+0.005);
    gain.gain.exponentialRampToValueAtTime(0.0001, now+0.10);
    osc.connect(gain).connect(ac.destination);
    osc.start(now);
    osc.stop(now+0.12);
  }

  // Right-hand wheel geometry (2×2 spacing, 4-pace stagger, step-short on exit)
  function pos(f,d,t){
    const r = 1 + 2*f;
    const tau = t - 4*d;
    if(tau < 0){
      return {x:-r, y: 0.5*(t - 4*d)};
    }else if(tau <= 16){
      const th = (tau/16) * (Math.PI/2);
      return {x: -r*Math.cos(th), y: r*Math.sin(th)};
    }else{
      return {x: 0.5*(tau-16), y: r};
    }
  }

  // Fixed camera
  let cam = null;
  function recalcCamera(){
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(let tt=0; tt<=36; tt++){
      for(let f=0; f<F; f++){
        for(let d=0; d<R; d++){
          const p = pos(f,d,tt);
          if(p.x<minX) minX=p.x;
          if(p.x>maxX) maxX=p.x;
          if(p.y<minY) minY=p.y;
          if(p.y>maxY) maxY=p.y;
        }
      }
    }
    const m=2;
    minX-=m; maxX+=m; minY-=m; maxY+=m;
    const OX = (stage.width  - px*(maxX - minX))/2 - px*minX;
    const OY = (stage.height - px*(maxY - minY))/2 + px*maxY;
    cam = {OX, OY, minX, maxX, minY, maxY};
  }
  recalcCamera();

  // *** Flipped guide lines ***
  function drawGuides(){
    ctx.save();
    ctx.translate(cam.OX, cam.OY);

    // dashed style
    ctx.setLineDash([5,6]); 
    ctx.lineWidth = 1; 
    ctx.strokeStyle = '#909fbc';

    // Wheel line (baseline)
    ctx.beginPath(); 
    ctx.moveTo(px*cam.minX, 0); 
    ctx.lineTo(px*cam.maxX, 0); 
    ctx.stroke();

    // Concentric quarter-circles on the RIGHT-hand wheel (mirror across y-axis):
    // Draw via sampled polyline to guarantee correct quadrant (lower-left in canvas coords).
    const steps = 36;
    for(let f=0; f<F; f++){
      const r = 1 + 2*f;
      ctx.beginPath();
      for(let i=0;i<=steps;i++){
        const a = (i/steps) * (Math.PI/2); // 0..90°
        const xw = -r * Math.cos(a);       // world x (mirrored)
        const yw =  r * Math.sin(a);       // world y (up)
        const cx = px * xw;
        const cy = -px * yw;               // canvas y-down
        if(i===0) ctx.moveTo(cx, cy); else ctx.lineTo(cx, cy);
      }
      ctx.stroke();
    }

    // Rays (guides at 0..90° mirrored): go into lower-left quadrant on canvas
    const Rmax = 1 + 2*(F-1);
    for(let i=0;i<=4;i++){
      const a = (i/4) * (Math.PI/2);
      ctx.beginPath(); 
      ctx.moveTo(0,0);
      ctx.lineTo(-Math.cos(a)*px*Rmax, -Math.sin(a)*px*Rmax);
      ctx.stroke();
    }

    // Pivot mini-arc (also mirrored)
    ctx.setLineDash([]);
    ctx.lineWidth = 8; 
    ctx.strokeStyle = '#2948a8';
    const r0 = px*0.7;
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const a = (i/steps) * (Math.PI/2);
      const xw = -Math.cos(a) * (r0/px);
      const yw =  Math.sin(a) * (r0/px);
      const cx = px * xw;
      const cy = -px * yw;
      if(i===0) ctx.moveTo(cx, cy); else ctx.lineTo(cx, cy);
    }
    ctx.stroke();

    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,stage.width,stage.height);
    drawGuides();
    ctx.save(); 
    ctx.translate(cam.OX, cam.OY);
    const half = Math.max(4,Math.min(8,px*0.18));
    for(let f=0; f<F; f++){
      for(let d=0; d<R; d++){
        const p = pos(f,d,t);
        ctx.fillStyle = '#2948a8';
        ctx.fillRect(px*p.x - half, -(px*p.y) - half, 2*half, 2*half);
      }
    }
    ctx.restore();
    ctx.fillStyle = 'rgba(41,72,168,.10)'; 
    ctx.fillRect(stage.width-120, 14, 100, 38);
    ctx.fillStyle = '#2948a8'; 
    ctx.font = 'bold 20px system-ui,-apple-system,Segoe UI'; 
    ctx.fillText('t = ' + t, stage.width-95, 40);
  }

  setT(0,false);
})();
</script>
</body>
</html>
